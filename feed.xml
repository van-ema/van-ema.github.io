<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://van-ema.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://van-ema.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-12-14T21:12:01+00:00</updated><id>https://van-ema.github.io/feed.xml</id><title type="html">Emanuele’s Log</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Rust MIR Instrumentation</title><link href="https://van-ema.github.io/blog/2025/mir-instrumentation/" rel="alternate" type="text/html" title="Rust MIR Instrumentation"/><published>2025-12-14T15:12:00+00:00</published><updated>2025-12-14T15:12:00+00:00</updated><id>https://van-ema.github.io/blog/2025/mir-instrumentation</id><content type="html" xml:base="https://van-ema.github.io/blog/2025/mir-instrumentation/"><![CDATA[<h1 id="instrumenting-rust-mir-with-a-custom-compiler-driver">Instrumenting Rust MIR with a Custom Compiler Driver</h1> <p>Rust’s Mid-level Intermediate Representation (MIR) is one of the most powerful—but least documented—extension points in the compiler. If you want to observe reference creation, track memory, or build dynamic analyses, MIR is usually the right layer.</p> <p>This post explains <strong>how to instrument Rust MIR in practice</strong>, focusing on three concrete questions:</p> <ol> <li><strong>Which rustc APIs to use</strong></li> <li><strong>How to build a custom rustc driver</strong></li> <li><strong>How to link a runtime crate safely (even under LTO)</strong></li> </ol> <p>All examples are based on a working multi-crate workspace.</p> <hr/> <h2 id="1-which-rustc-apis-to-use">1. Which rustc APIs to Use</h2> <h3 id="nightly-and-rustc_private">Nightly and <code class="language-plaintext highlighter-rouge">rustc_private</code></h3> <p>MIR instrumentation is not available on stable Rust. You must use nightly and opt into rustc’s internal APIs:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#![feature(rustc_private)]</span>

<span class="k">extern</span> <span class="k">crate</span> <span class="n">rustc_driver</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">crate</span> <span class="n">rustc_interface</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">crate</span> <span class="n">rustc_middle</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">crate</span> <span class="n">rustc_mir_transform</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">crate</span> <span class="n">rustc_span</span><span class="p">;</span>
</code></pre></div></div> <h3 id="the-optimized_mir-query">The <code class="language-plaintext highlighter-rouge">optimized_mir</code> Query</h3> <p>Rustc exposes MIR through <em>queries</em>. The most useful query for instrumentation is <code class="language-plaintext highlighter-rouge">optimized_mir</code>, because it runs <strong>after MIR is built and optimized</strong>, but <strong>before</strong> codegen to LLVM.</p> <p>In a custom driver you can override this query via <code class="language-plaintext highlighter-rouge">Config::override_queries</code>:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_config</span><span class="py">.override_queries</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(|</span><span class="n">_session</span><span class="p">,</span> <span class="n">queries</span><span class="p">|</span> <span class="p">{</span>
    <span class="n">queries</span><span class="py">.optimized_mir</span> <span class="o">=</span> <span class="n">CUSTOM_OPT_MIR</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div> <p>Your hook has the shape:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">CUSTOM_OPT_MIR</span><span class="p">:</span> <span class="k">for</span><span class="o">&lt;</span><span class="nv">'tcx</span><span class="o">&gt;</span> <span class="k">fn</span><span class="p">(</span><span class="n">tcx</span><span class="p">:</span> <span class="n">TyCtxt</span><span class="o">&lt;</span><span class="nv">'tcx</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">def</span><span class="p">:</span> <span class="n">LocalDefId</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'tcx</span> <span class="n">Body</span><span class="o">&lt;</span><span class="nv">'tcx</span><span class="o">&gt;</span> <span class="o">=</span>
    <span class="p">|</span><span class="n">tcx</span><span class="p">,</span> <span class="n">def</span><span class="p">|</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">body</span> <span class="o">=</span> <span class="p">(</span><span class="nn">rustc_interface</span><span class="p">::</span><span class="n">DEFAULT_QUERY_PROVIDERS</span><span class="py">.optimized_mir</span><span class="p">)(</span><span class="n">tcx</span><span class="p">,</span> <span class="n">def</span><span class="p">)</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="c1">// Your MIR instrumentation goes here.</span>
        <span class="n">MyOptimizationPass</span><span class="nf">.run_pass</span><span class="p">(</span><span class="n">tcx</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">body</span><span class="p">);</span>

        <span class="n">tcx</span><span class="py">.arena</span><span class="nf">.alloc</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
    <span class="p">};</span>
</code></pre></div></div> <p>The important pattern is:</p> <ol> <li>Call the default provider (<code class="language-plaintext highlighter-rouge">DEFAULT_QUERY_PROVIDERS.optimized_mir</code>) to get rustc’s MIR.</li> <li>Clone it (you need an owned <code class="language-plaintext highlighter-rouge">Body</code> to edit).</li> <li>Modify it (insert statements/terminators, add locals, etc.).</li> <li>Allocate it in the compiler arena and return <code class="language-plaintext highlighter-rouge">&amp;'tcx Body&lt;'tcx&gt;</code>.</li> </ol> <p>If you pick an earlier query (like <code class="language-plaintext highlighter-rouge">mir_built</code>) you’ll see less optimized MIR; if you pick a later stage you may miss the chance to inject cleanly before codegen.</p> <hr/> <h2 id="2-how-to-create-a-custom-rustc-driver">2. How to create a custom rustc driver</h2> <p>Rust no longer supports compiler plugins, so the standard approach is to <strong>replace <code class="language-plaintext highlighter-rouge">rustc</code></strong> with your own binary that embeds rustc and overrides queries.</p> <p>The basic structure is:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">CompilerCallbacks</span><span class="p">;</span>

<span class="k">impl</span> <span class="nn">rustc_driver</span><span class="p">::</span><span class="n">Callbacks</span> <span class="k">for</span> <span class="n">CompilerCallbacks</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">config</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">rustc_interface</span><span class="p">::</span><span class="n">Config</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">config</span><span class="py">.override_queries</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(|</span><span class="n">_session</span><span class="p">,</span> <span class="n">queries</span><span class="p">|</span> <span class="p">{</span>
            <span class="n">queries</span><span class="py">.optimized_mir</span> <span class="o">=</span> <span class="n">CUSTOM_OPT_MIR</span><span class="p">;</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">callbacks</span> <span class="o">=</span> <span class="n">CompilerCallbacks</span><span class="p">;</span>
    <span class="nn">rustc_driver</span><span class="p">::</span><span class="nf">run_compiler</span><span class="p">(</span><span class="o">&amp;</span><span class="nn">std</span><span class="p">::</span><span class="nn">env</span><span class="p">::</span><span class="nf">args</span><span class="p">()</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">callbacks</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>In practice you usually want a <strong>Cargo subcommand</strong> wrapper (<code class="language-plaintext highlighter-rouge">cargo-instrument-mir</code>) that runs <code class="language-plaintext highlighter-rouge">cargo build</code> but sets:</p> <ul> <li><code class="language-plaintext highlighter-rouge">RUSTC=/path/to/instrument-mir</code></li> </ul> <p>This makes the workflow feel like a normal Cargo command:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo instrument-mir <span class="nt">-p</span> hello <span class="nt">--release</span>
</code></pre></div></div> <hr/> <h2 id="3-how-to-link-a-runtime-crate-safely-even-under-lto">3. How to link a runtime crate safely (even under LTO)</h2> <p>MIR instrumentation usually needs a <strong>runtime crate</strong> to record events (log, track pointers, update global state, etc.). The compiler pass injects calls, but those calls must resolve and the runtime must not be stripped by the linker.</p> <h3 id="31-make-rustc-able-to-see-the-runtime">3.1 Make rustc able to see the runtime</h3> <p>If your driver injects calls like <code class="language-plaintext highlighter-rouge">runtime::__injected_hook(...)</code>, you must ensure rustc can resolve the <code class="language-plaintext highlighter-rouge">runtime</code> crate. A simple way is to add <code class="language-plaintext highlighter-rouge">-L</code> and <code class="language-plaintext highlighter-rouge">--extern</code> when your driver invokes rustc:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">runtime_path</span> <span class="o">=</span> <span class="s">"/path/to/workspace/target/release"</span><span class="p">;</span>

<span class="n">args</span><span class="nf">.push</span><span class="p">(</span><span class="s">"-Zunstable-options"</span><span class="nf">.to_string</span><span class="p">());</span>
<span class="n">args</span><span class="nf">.push</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"-L{runtime_path}"</span><span class="p">));</span>
<span class="n">args</span><span class="nf">.push</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"--extern=force:runtime={runtime_path}/libruntime.rlib"</span><span class="p">));</span>
</code></pre></div></div> <p>Notes:</p> <ul> <li><code class="language-plaintext highlighter-rouge">-L</code> tells rustc where to find <code class="language-plaintext highlighter-rouge">libruntime.rlib</code>.</li> <li><code class="language-plaintext highlighter-rouge">--extern=force:runtime=...</code> makes the crate available even if it is not referenced from source code.</li> </ul> <h3 id="32-keep-the-runtime-from-being-dead-stripped-especially-with-lto">3.2 Keep the runtime from being dead-stripped (especially with LTO)</h3> <p>With LTO enabled, the linker can remove crates and symbols that appear unused. Since the runtime is only referenced by injected MIR, it can look “unused” from the perspective of the normal Rust source.</p> <p>A robust pattern is to export a C ABI hook and <strong>force a reference to it</strong>:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[no_mangle]</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">__injected_hook</span><span class="p">(</span><span class="n">addr</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"__injected_hook called for address: 0x{:x}"</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="nd">macro_rules!</span> <span class="n">force_runtime</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$sym:path</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">#[used]</span>
        <span class="k">static</span> <span class="n">_FORCE_RUNTIME</span><span class="p">:</span> <span class="k">fn</span><span class="p">(</span><span class="nb">usize</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$sym</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="nd">force_runtime!</span><span class="p">(</span><span class="n">__injected_hook</span><span class="p">);</span>
</code></pre></div></div> <p>This does two things:</p> <ul> <li><code class="language-plaintext highlighter-rouge">#[no_mangle]</code> + <code class="language-plaintext highlighter-rouge">extern "C"</code> gives you a predictable symbol.</li> <li><code class="language-plaintext highlighter-rouge">#[used]</code> prevents the symbol from being dropped during optimization and linking.</li> </ul> <h3 id="33-use-a-stable-hook-abi">3.3 Use a stable hook ABI</h3> <p>Don’t pass typed references like <code class="language-plaintext highlighter-rouge">&amp;T</code> to the runtime hook. It’s brittle and can lead to invalid IR (especially under LTO). Instead, compute a stable representation in MIR (for example, a <code class="language-plaintext highlighter-rouge">usize</code> address) and pass that.</p> <p>On recent nightlies with strict provenance, the cast you want in MIR is typically:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">CastKind</span><span class="p">::</span><span class="n">PointerExposeProvenance</span>
</code></pre></div></div> <p>That converts a pointer-like value into an integer address in a way that rustc/LLVM accept.</p> <hr/> <h2 id="references">References</h2> <ul> <li><a href="https://jyn.dev/rustc-driver/">Writing a custom <code class="language-plaintext highlighter-rouge">rustc</code> driver</a></li> </ul>]]></content><author><name></name></author><category term="Rust"/><summary type="html"><![CDATA[How to inject calls inside MIR]]></summary></entry><entry><title type="html">(Rust) Pointers provenance is real</title><link href="https://van-ema.github.io/blog/2025/provenance/" rel="alternate" type="text/html" title="(Rust) Pointers provenance is real"/><published>2025-01-20T15:12:00+00:00</published><updated>2025-01-20T15:12:00+00:00</updated><id>https://van-ema.github.io/blog/2025/provenance</id><content type="html" xml:base="https://van-ema.github.io/blog/2025/provenance/"><![CDATA[<h3 id="pointers-are-not-integers">Pointers are not integers</h3> <p>and Rust made it very clear to everyone.</p> <p>Have you ever heard of pointer provenance? If not, don’t worry—you’re not alone. Even if you’ve been programming for 10 years, you might have never needed to think about it. But here’s the thing: provenance is a bit like those “apparent forces” in physics—it exists because we can observe its effects. And since it’s there, we need to define it to make sense of how things really work under the hood.</p> <p>So, where do we even start? How do we know pointer provenance exists, and how can we find it? Let’s break it down.</p> <h2 id="provenance-in-rust">Provenance in Rust</h2> <p>The claim that “pointers are just integers” doesn’t hold up, as demonstrated by <a href="https://godbolt.org/z/ce4bjqjbM">counterexample</a> and explained in [RFC3559 of Rust])https://rust-lang.github.io/rfcs/3559-rust-has-provenance.html). But here’s the catch — while provenance exists, we haven’t really had a way to interact with it directly in our code. That changes with Rust 1.84. The stable release introduces new APIs that let developers manipulate pointers and explicitly define their provenance.</p> <p>As the Rust documentation state</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>It is undefined behavior to offset a pointer across a memory range that is not contained in the allocated object it is derived from
</code></pre></div></div> <p>Rust 1.84 introduces <code class="language-plaintext highlighter-rouge">wrapping_offset</code> to create a pointer that points outside its provenance (dereferencing the pointer is still UB!) However the LLVM IR for <code class="language-plaintext highlighter-rouge">offset</code> and <code class="language-plaintext highlighter-rouge">wrapping_offet</code> is quite similar. Why then <code class="language-plaintext highlighter-rouge">offset</code> leads to undefined behavior even when the result is not deferenced? Let’s look at the <a href="https://godbolt.org/z/3Mz7serhx">LLVM IR here</a></p> <p>with <code class="language-plaintext highlighter-rouge">offset</code>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  store i64 6, ptr %count.dbg.spill.i2, align 8
; call core::ptr::const_ptr::&lt;impl *const T&gt;::offset::precondition_check
  call void 
  @"_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$6offset18precondition_check17h058d8998d9a55876E"(ptr %_6, i64 6, i64 1) #20, !dbg !2498
  %_0.i4 = getelementptr inbounds i8, ptr %_6, i64 6, !dbg !2500
</code></pre></div></div> <p>with <code class="language-plaintext highlighter-rouge">wrapped_offset</code>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> store i64 6, ptr %count.dbg.spill.i2, align 8
  #dbg_declare(ptr %count.dbg.spill.i2, !2351, !DIExpression(), !2354)
  %9 = getelementptr i8, ptr %_6, i64 6, !dbg !2355
</code></pre></div></div> <p>and what LLVM LangRef says about Gep instruction?</p> <blockquote> <p>The result value of the getelementptr may be outside the object pointed to by the base pointer. The result value may not necessarily be used to access memory though, even if it happens to point into allocated storage</p> </blockquote> <p>and again</p> <blockquote> <p>The getelementptr instruction may have a number of attributes that impose additional rules. If any of the rules are violated, the result vale is a <a href="https://llvm.org/docs/LangRef.html#poisonvalues">poison value</a>.</p> </blockquote> <p>and therefore and out-of-bound Gep which is not used afterwards is not UB.</p> <h3 id="further-readings">Further readings:</h3> <ul> <li><a href="https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance">Strict provenance in Rust</a></li> <li><a href="https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html">Pointers Are Complicated blog post by Ralf’s Jung</a></li> </ul>]]></content><author><name></name></author><category term="Rust"/><summary type="html"><![CDATA[Provenance and Rust]]></summary></entry></feed>