<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://van-ema.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://van-ema.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-01-20T22:51:13+00:00</updated><id>https://van-ema.github.io/feed.xml</id><title type="html">Emanuele’s blog</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Pointers provenance is real</title><link href="https://van-ema.github.io/blog/2025/provenance/" rel="alternate" type="text/html" title="Pointers provenance is real"/><published>2025-01-20T15:12:00+00:00</published><updated>2025-01-20T15:12:00+00:00</updated><id>https://van-ema.github.io/blog/2025/provenance</id><content type="html" xml:base="https://van-ema.github.io/blog/2025/provenance/"><![CDATA[<h3 id="pointers-are-not-integers">Pointers are not integers</h3> <p>and Rust made it very clear to everyone.</p> <p>I may understand if you’ve never heard about pointers provenace. Maybe you are a 10yoe programmer and still you never needed to know what provenance is. Similar to apparent forces in Physics, Provenance exists, just because we can see it. Therefore, we must define so that the world can work as it actualy does. So let’s start from the beginning. How do we know provenance exixsts and where to find it?</p> <h2 id="provenance-in-rust">Provenance in Rust</h2> <p>The statement ‘pointers are just integers’ is refuted by the <a href="https://godbolt.org/z/ce4bjqjbM">counterexample</a> illustrated in [RFC3559 of Rust])https://rust-lang.github.io/rfcs/3559-rust-has-provenance.html). So we now know that provenance exists but we don’t actually have a mean to use it when we code. isn’t it? Rust 1.84 stable version introduce APIs to manipulate pointers and specify provenance explicitly. Rust documentation states:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>It is undefined behavior to offset a pointer across a memory range that is not contained in the allocated object it is derived from
</code></pre></div></div> <p>Rust 1.84 introduces <code class="language-plaintext highlighter-rouge">wrapping_offset</code> to create a pointer that points outside its provenance (dereferencing the pointer is still UB!) However the LLVM IR for <code class="language-plaintext highlighter-rouge">offset</code> and <code class="language-plaintext highlighter-rouge">wrapping_offet</code> is quite similar. Why then <code class="language-plaintext highlighter-rouge">offset</code> leads to undefined behavior even when the result is not deferenced? Let’s look at the <a href="https://godbolt.org/z/3Mz7serhx">LLVM IR here</a></p> <p>with <code class="language-plaintext highlighter-rouge">offset</code>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  store i64 6, ptr %count.dbg.spill.i2, align 8
; call core::ptr::const_ptr::&lt;impl *const T&gt;::offset::precondition_check
  call void 
  @"_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$6offset18precondition_check17h058d8998d9a55876E"(ptr %_6, i64 6, i64 1) #20, !dbg !2498
  %_0.i4 = getelementptr inbounds i8, ptr %_6, i64 6, !dbg !2500
</code></pre></div></div> <p>with <code class="language-plaintext highlighter-rouge">wrapped_offset</code>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> store i64 6, ptr %count.dbg.spill.i2, align 8
  #dbg_declare(ptr %count.dbg.spill.i2, !2351, !DIExpression(), !2354)
  %9 = getelementptr i8, ptr %_6, i64 6, !dbg !2355
</code></pre></div></div> <p>and what LLVM LangRef says about Gep instruction? The result value of the getelementptr may be outside the object pointed to by the base pointer. The result value may not necessarily be used to access memory though, even if it happens to point into allocated storage</p> <p>and again The getelementptr instruction may have a number of attributes that impose additional rules. If any of the rules are violated, the result value is a <a href="https://llvm.org/docs/LangRef.html#poisonvalues">poison value</a>.</p> <p>and therefore and out-of-bound Gep which is not used afterwards is not UB.</p>]]></content><author><name></name></author><category term="Rust"/><summary type="html"><![CDATA[Provenance and Rust]]></summary></entry></feed>