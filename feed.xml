<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://van-ema.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://van-ema.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-03-08T15:19:49+00:00</updated><id>https://van-ema.github.io/feed.xml</id><title type="html">Emanuele’s notes</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">(Rust) Pointers provenance is real</title><link href="https://van-ema.github.io/blog/2025/provenance/" rel="alternate" type="text/html" title="(Rust) Pointers provenance is real"/><published>2025-01-20T15:12:00+00:00</published><updated>2025-01-20T15:12:00+00:00</updated><id>https://van-ema.github.io/blog/2025/provenance</id><content type="html" xml:base="https://van-ema.github.io/blog/2025/provenance/"><![CDATA[<h3 id="pointers-are-not-integers">Pointers are not integers</h3> <p>and Rust made it very clear to everyone.</p> <p>Have you ever heard of pointer provenance? If not, don’t worry—you’re not alone. Even if you’ve been programming for 10 years, you might have never needed to think about it. But here’s the thing: provenance is a bit like those “apparent forces” in physics—it exists because we can observe its effects. And since it’s there, we need to define it to make sense of how things really work under the hood.</p> <p>So, where do we even start? How do we know pointer provenance exists, and how can we find it? Let’s break it down.</p> <h2 id="provenance-in-rust">Provenance in Rust</h2> <p>The claim that “pointers are just integers” doesn’t hold up, as demonstrated by <a href="https://godbolt.org/z/ce4bjqjbM">counterexample</a> and explained in [RFC3559 of Rust])https://rust-lang.github.io/rfcs/3559-rust-has-provenance.html). But here’s the catch — while provenance exists, we haven’t really had a way to interact with it directly in our code. That changes with Rust 1.84. The stable release introduces new APIs that let developers manipulate pointers and explicitly define their provenance.</p> <p>As the Rust documentation state</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>It is undefined behavior to offset a pointer across a memory range that is not contained in the allocated object it is derived from
</code></pre></div></div> <p>Rust 1.84 introduces <code class="language-plaintext highlighter-rouge">wrapping_offset</code> to create a pointer that points outside its provenance (dereferencing the pointer is still UB!) However the LLVM IR for <code class="language-plaintext highlighter-rouge">offset</code> and <code class="language-plaintext highlighter-rouge">wrapping_offet</code> is quite similar. Why then <code class="language-plaintext highlighter-rouge">offset</code> leads to undefined behavior even when the result is not deferenced? Let’s look at the <a href="https://godbolt.org/z/3Mz7serhx">LLVM IR here</a></p> <p>with <code class="language-plaintext highlighter-rouge">offset</code>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  store i64 6, ptr %count.dbg.spill.i2, align 8
; call core::ptr::const_ptr::&lt;impl *const T&gt;::offset::precondition_check
  call void 
  @"_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$6offset18precondition_check17h058d8998d9a55876E"(ptr %_6, i64 6, i64 1) #20, !dbg !2498
  %_0.i4 = getelementptr inbounds i8, ptr %_6, i64 6, !dbg !2500
</code></pre></div></div> <p>with <code class="language-plaintext highlighter-rouge">wrapped_offset</code>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> store i64 6, ptr %count.dbg.spill.i2, align 8
  #dbg_declare(ptr %count.dbg.spill.i2, !2351, !DIExpression(), !2354)
  %9 = getelementptr i8, ptr %_6, i64 6, !dbg !2355
</code></pre></div></div> <p>and what LLVM LangRef says about Gep instruction?</p> <blockquote> <p>The result value of the getelementptr may be outside the object pointed to by the base pointer. The result value may not necessarily be used to access memory though, even if it happens to point into allocated storage</p> </blockquote> <p>and again</p> <blockquote> <p>The getelementptr instruction may have a number of attributes that impose additional rules. If any of the rules are violated, the result vale is a <a href="https://llvm.org/docs/LangRef.html#poisonvalues">poison value</a>.</p> </blockquote> <p>and therefore and out-of-bound Gep which is not used afterwards is not UB.</p> <h3 id="further-readings">Further readings:</h3> <ul> <li><a href="https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance">Strict provenance in Rust</a></li> <li><a href="https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html">Pointers Are Complicated blog post by Ralf’s Jung</a></li> </ul>]]></content><author><name></name></author><category term="Rust"/><summary type="html"><![CDATA[Provenance and Rust]]></summary></entry></feed>